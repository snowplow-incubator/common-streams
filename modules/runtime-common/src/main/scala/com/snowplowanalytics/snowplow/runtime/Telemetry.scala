/*
 * Copyright (c) 2023-present Snowplow Analytics Ltd. All rights reserved.
 *
 * This program is licensed to you under the Snowplow Community License Version 1.0,
 * and you may not use this file except in compliance with the Snowplow Community License Version 1.0.
 * You may obtain a copy of the Snowplow Community License Version 1.0 at https://docs.snowplow.io/community-license-1.0
 */
package com.snowplowanalytics.snowplow.runtime

import cats.implicits._
import cats.effect.{Async, Sync}
import com.snowplowanalytics.iglu.core.{SchemaKey, SchemaVer, SelfDescribingData}
import fs2.Stream
import io.circe._
import io.circe.syntax._
import io.circe.config.syntax._
import io.circe.generic.semiauto._
import org.http4s.client.{Client => Http4sClient}
import org.http4s.{Method, ParseFailure, Query, Request, Uri}
import org.http4s.circe.jsonEncoder
import org.typelevel.log4cats.Logger
import org.typelevel.log4cats.slf4j.Slf4jLogger

import com.snowplowanalytics.iglu.core.circe.implicits._

import scala.concurrent.duration.FiniteDuration
import java.util.UUID

object Telemetry {

  case class Config(
    disable: Boolean,
    interval: FiniteDuration,
    collectorUri: Uri,
    userProvidedId: Option[String],
    autoGeneratedId: Option[String],
    instanceId: Option[String],
    moduleName: Option[String],
    moduleVersion: Option[String]
  )

  object Config {
    implicit def telemetryConfigDecoder: Decoder[Config] = {
      implicit val http4sUriDecoder: Decoder[Uri] =
        Decoder[String].emap(s => Either.catchOnly[ParseFailure](Uri.unsafeFromString(s)).leftMap(_.toString))
      deriveDecoder
    }
  }

  private implicit def unsafeLogger[F[_]: Sync]: Logger[F] =
    Slf4jLogger.getLogger[F]

  def stream[F[_]: Async](
    config: Config,
    appInfo: AppInfo,
    httpClient: Http4sClient[F]
  ): Stream[F, Nothing] =
    if (config.disable)
      Stream.never
    else {
      val stream = for {
        uuid <- Stream.eval(Async[F].delay(UUID.randomUUID))
        sdj = makeHeartbeatEvent(config, appInfo, uuid)
        req = makeHeartbeatRequest[F](config, sdj, appInfo.name)
        _ <- Stream.unit ++ Stream.fixedDelay[F](config.interval)
        _ <- Stream.eval(executeHttpRequest(httpClient, req))
      } yield ()

      stream.drain
    }

  private def makeHeartbeatRequest[F[_]](
    config: Config,
    sdj: SelfDescribingData[Json],
    appName: String
  ): Request[F] = {
    val uri = (config.collectorUri / "com.snowplowanalytics.iglu" / "v1")
      .copy(query = Query("aid" -> Some(appName), "p" -> Some("srv")))
    Request[F](Method.POST, uri).withEntity(sdj.normalize)
  }

  private def executeHttpRequest[F[_]: Async](
    httpClient: Http4sClient[F],
    request: Request[F]
  ): F[Unit] =
    httpClient
      .run(request)
      .use { response =>
        if (response.status.isSuccess) Sync[F].unit
        else {
          Logger[F].info(show"Webhook ${request.uri} returned status ${response.status}")
        }
      }
      .handleErrorWith { _ =>
        // Don't log the exception, because http4s retry middleware already logs it
        Logger[F].info(show"Webhook ${request.uri} resulted in exception without a response")
      }

  private def makeHeartbeatEvent(
    config: Config,
    appInfo: AppInfo,
    appGeneratedId: UUID
  ): SelfDescribingData[Json] =
    SelfDescribingData(
      SchemaKey("com.snowplowanalytics.oss", "oss_context", "jsonschema", SchemaVer.Full(1, 0, 1)),
      Json.obj(
        "userProvidedId" -> config.userProvidedId.asJson,
        "autoGeneratedId" -> config.autoGeneratedId.asJson,
        "moduleName" -> config.moduleName.asJson,
        "moduleVersion" -> config.moduleVersion.asJson,
        "instanceId" -> config.instanceId.asJson,
        "appGeneratedId" -> appGeneratedId.toString.asJson,
        "cloud" -> appInfo.cloud.asJson,
        "region" -> Json.Null,
        "applicationName" -> appInfo.name.asJson,
        "applicationVersion" -> appInfo.version.asJson
      )
    )

}
